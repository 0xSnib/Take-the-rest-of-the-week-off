import requests
import datetime

BINANCE_API = "https://api.binance.com/api/v3/klines"
PAIR = "ETHUSDT"
INTERVAL = "1h"
LIMIT = 52 * 7 * 24  # 52 weeks * 7 days * 24 hours

# Parameters
account_size = 10000  # starting with $10000, for example
risk_fraction = 0.02
position_fraction = 0.8

def fetch_data():
    params = {
        "symbol": PAIR,
        "interval": INTERVAL,
        "limit": LIMIT
    }
    response = requests.get(BINANCE_API, params=params)
    return response.json()

def backtest(data):
    best_combination = None
    best_profit = 0

    for buy_hour in range(24):
        for sell_hour in range(24):
            account_balance = account_size
            i = 0
            while i < len(data) - 1:  # Subtracting 1 for safety
                date = datetime.datetime.fromtimestamp(data[i][0] / 1000)

                if date.weekday() == 0 and date.hour == buy_hour:  # Monday
                    buy_price = float(data[i][4])  # Close price
                    position_size = account_balance * position_fraction
                    stop_loss_price = buy_price - (buy_price * risk_fraction)

                    # Check if stop loss is hit in the next 2 days
                    stop_loss_hit = False
                    for j in range(1, 49):  # Check next 48 hours (2 days)
                        if (i + j) >= len(data) or float(data[i+j][3]) <= stop_loss_price:  # Check low price
                            stop_loss_hit = True
                            account_balance -= position_size * risk_fraction
                            break

                    # Increment index to Wednesday
                    while i < len(data) - 1 and (date.weekday() != 2 or date.hour != sell_hour):
                        i += 1
                        date = datetime.datetime.fromtimestamp(data[i][0] / 1000)

                    if not stop_loss_hit and i < len(data):  # Check if we're not out of data
                        sell_price = float(data[i][4])  # Close price
                        profit = (sell_price - buy_price) * (position_size / buy_price)
                        account_balance += profit

                i += 1

            if account_balance > best_profit:
                best_profit = account_balance
                best_combination = (buy_hour, sell_hour)

    return best_combination, best_profit

data = fetch_data()
best_time, profit = backtest(data)

print(f"Best time to buy/sell: Monday {best_time[0]}:00, Wednesday {best_time[1]}:00")
print(f"Profit at the end of the year with best timings: ${profit:.2f}")
